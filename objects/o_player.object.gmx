<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-101</depth>
  <persistent>0</persistent>
  <parentName>o_entityParent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Misc Declarations

slotIndex = -1; // This to keep track of points, mostly
input = noone;

ballHeld = false;
canCatch = true;

onGroundPrev = false;

canDblJump = true;
blink      = true;
bounced    = false;
freeze     = false;

tempPaint    = false;
touchPaint   = 1//false;
wallJump     = 1//false;
dblJump      = 1//false;
dblJumpSpray = 1//false;


// Spring Vars
val    = 0;
vel    = 0;
target = 0;
zeta   = 0.0001;   //0.15
omega  = 2 * pi; //8
h      = 0.04;   //0.02
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Motion blur

/*
blur = 4;

for (var i = 0; i &lt; blur; i++) {
    ax[i]  = x;
    ay[i]  = y;
    axs[i] = xscale;
    ays[i] = yscale;
    av[i]  = val;
}
*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement &amp; Visual Variables

// Inherit o_entityParent variables
event_inherited();

facing = RIGHT;

/*
if (instance_number(o_player) &gt; 1) {
    x = 10000;
    y = 10000;
    
    instance_destroy();
}

if (!instance_exists(o_camera))
    instance_create(x, y, o_camera);

    //***
    //why are these numbers in particular being chosen?
view_xview[0] = max(0, min(x - (640 * 0.5), room_width - 640));
view_yview[0] = max(0, min(y - (360 * 0.5) - 24, room_height - 360));
*/
// Movement ///////////////////////////////////////////////////////////////////

var oldFPS, newFPS;

oldFPS = 30;
newFPS = 30;

m = newFPS / oldFPS;

groundAccel = 1.00 / (sqr(newFPS / oldFPS)); // 1.00
groundFric  = 2.00 / (sqr(newFPS / oldFPS)); // 2.00
airAccel    = 1.00 / (sqr(newFPS / oldFPS)); // 1.00
airFric     = 0.01 / (sqr(newFPS / oldFPS)); // 0.01
vxMax       = 7.00 * m; // 6.50
vyMax       = 18.0 * m; // 16.0
jumpHeight  = 8.00 * m; // 8.00
gravNorm    = 0.70 / (sqr(newFPS / oldFPS)); // 0.80
gravSlide   = 0.30 / (sqr(newFPS / oldFPS)); // 0.30

clingTime   = 4.0 * (1 / m);

// Misc ///////////////////////////////////////////////////////////////////////


// Initialize properties
movement  = IDLE;
// if image_xscale equals -1, the image flips.
// a nice easy way to deal with sprite mirroring
show_debug_message("image_xscale is " + string(image_xscale));
image_xscale = facing; // Change xscale in editor to adjust initial facing

// ***
// Don't know what this means?
// Fuck that
image_xscale = clamp(image_xscale, -1, 1);
image_yscale = clamp(image_yscale, -1, 1);

// For squash + stretch
xscale = 1;
yscale = 1;

///////////////////////////////////////////////////////////////////////////////

// Legacy code, haha
sticking = false
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sensors

holder = instance_create(0,0,o_ball_holder);
holder.owner = self;
sensor = instance_create(0,0,o_sensor);
sensor.owner = self;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Death effects, set up player respawn

with (o_game) {
    shake   = true;
    alarm[0] = 8;
}

/* old special effects
for (var i = 0; i &lt; 32; i++)
    instance_create(x, y - 8, oPaintBullet);
*/

// ****
// This a brilliant way to basically use an object as a script.
// You can create an instance with a WITH statement and then
// immediately declare a set of variables within it, funtionally
// the same as passing an argument to a function.
// This seems to work so long as the code you want run by the new
// object is in the DRAW END event.
// \/\/\/\/
// Recreate player where they were last created

/*
with (instance_create(0, 0, o_spawnPlayer)) {
    xx = other.xstart;
    yy = other.ystart;
}

audio_play_sound(sfxDeath, 0, 0);

global.IsCoinCollected = false;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset dog's ability to catch ball

show_debug_message("can_catch reset!");

canCatch = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// TempPaint
tempPaint = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sticking
sticking = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Entity Step 2.0 ¯\_(ツ)_/¯

event_inherited();

/*
if (!freeze) {
    cx += vx;
    cy += vy;
    vxNew = round(cx);
    vyNew = round(cy);
    cx -= vxNew;
    cy -= vyNew;
    
    
    jumped = false;
    landed = false;

    repeat(abs(vyNew)) {
        if (!PlatformCheck())
            y += sign(vy);
        else {
            vy = 0;
            break;
        }
    }
    
    if (platformTarget) {
        if (!onGround)
            landed = true;
        
        if (landed)
            with (platformTarget) other.vy = 0;
        else
            with (platformTarget) other.vy = 0;
    }
    
    repeat(abs(vxNew)) {
        if (!place_meeting(x + sign(vx), y, oParSolid))
            x += sign(vx);
        else {
            vx = 0;
            break;
        }
    }
}
*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Death

//if (place_meeting(x, y, o_solid) || place_meeting(x, y, oParHazard))
//    instance_destroy();

if (bbox_right &lt; 0 || bbox_left &gt; room_width || bbox_top &gt; room_height || bbox_bottom &lt; 0)
    instance_destroy();
    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Procedural Animation

if (!freeze) {
    if (vx &gt; 0)
        target = -4;
    else if (vx &lt; 0)
        target = 4;
    else 
        target = 0;
    
    xscale = scr_approach(xscale, 1, 0.08);
    yscale = scr_approach(yscale, 1, 0.08);
    
    var f, hh, oo, hoo, hhoo, detInv, detX, detV;
    
    f      = 1.0 + (2.0 * h * zeta * omega);
    hh     = h * h;
    oo     = omega * omega;
    hoo    = h * oo;
    hhoo   = h * hoo;
    detInv = 1.0 / (f + hhoo);
    detX   = (f * val) + (h * vel) + (hhoo * target);
    detV   = vel + (hoo * (target - val));
    val    = detX * detInv;
    vel    = detV * detInv;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update motion blur

/*
for (var i = (blur - 2); i &gt;= 0; i--) {
    ax[i  + 1] =  ax[i];
    ay[i  + 1] =  ay[i];
    axs[i + 1] = axs[i];
    ays[i + 1] = ays[i];
    av[i  + 1] =  av[i];
}

 ax[0] = x;
 ay[0] = y;
axs[0] = xscale;
ays[0] = yscale;
 av[0] = val;
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set up

var onGroundPrev = onGround; // Remembers where the player was before calculations

event_inherited(); // Check for collisions and if currently onGround

if (onGround &amp;&amp; !onGroundPrev) { // Player is landing
    xscale = 1.5;
    yscale = 0.5;
    canDblJump = true;
    
    /* Spray paint
    // Paint on landing
    if (touchPaint || tempPaint)
        for (var i = 0; i &lt; 16; i++)
            instance_create(x, y, oPaint);
        
    audio_play_sound(sfxLand, 0, 0); 
    */
}

if (cLeft || cRight) { // if the player is touching a wall.
    // Reset 
    canDblJump = true;
    blink       = true;
}

// Paint
/*
if (touchPaint || tempPaint) {
    //if (vx != 0 || vy != 0)
    //    with (oFxGrid)
    //        FxGridExplode(grid, other.x + random_range(-8, 8), other.y - 8 + random_range(-8, 8), random_range(8, 16), random_range(8, 16));
      
    var flag = false;
      
    if (/*(vx != 0 || vy != 0) &amp;&amp; */ /*(place_meeting(x, y - 1, oBlock) || place_meeting(x, y - 1, oLockBlock)))
        for (var i = 0; i &lt; 8; i++)
            instance_create(x, bbox_top, oPaint);   
            
    if ((vx != 0 || vy != 0) &amp;&amp; (place_meeting(x, y + 1, oBlock) || place_meeting(x, y + 1, oLockBlock))) {
        for (var i = 0; i &lt; 8; i++)
            instance_create(x, bbox_bottom, oPaint); 
        //audio_play_sound(sfxSlide, 0, 0);
        flag = true;
    } 
            
    if ((vx != 0 || vy != 0) &amp;&amp; (place_meeting(x + 1, y, oBlock) || place_meeting(x + 1, y, oLockBlock))) {
        for (var i = 0; i &lt; 8; i++)
            instance_create(bbox_right, y - 8, oPaint); 
        //audio_play_sound(sfxSlide, 0, 0);
        flag = true;
    } 
            
    if ((vx != 0 || vy != 0) &amp;&amp; (place_meeting(x - 1, y, oBlock) || place_meeting(x - 1, y, oLockBlock))) {
        for (var i = 0; i &lt; 8; i++)
            instance_create(bbox_left, y - 8, oPaint); 
        //audio_play_sound(sfxSlide, 0, 0);
        flag = true;
    } 
    
    if (flag &amp;&amp; !freeze) {
        if (!audio_is_playing(sfxSlide)) {
            audio_sound_gain(sfxSlide, 0, 0);  
            audio_play_sound(sfxSlide, 0, false);
            audio_sound_gain(sfxSlide, 0.8, 30);  
        } else {
            audio_sound_gain(sfxSlide, 0.8, 30);
        }
    } else {
        if (audio_is_playing(sfxSlide)) {
            audio_sound_gain(sfxSlide, 0, 15);  
        }  
    }
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement from input

if input != noone {

    if (input.right || input.left)
        omega = 6 * pi;
    else
        omega = 3 * pi;
    
    // Apply the correct form of acceleration and friction
    var tempAccel, tempFric;
    
    if (onGround) {  
        tempAccel = groundAccel;
        tempFric  = groundFric;
    } else {
        tempAccel = airAccel;
        tempFric  = airFric;
    }
    
    // Wall cling to avoid accidental push-off
    /*
    if (wallJump) {
        if ((!cRight &amp;&amp; !cLeft) || onGround) {
            canStick = true;
            sticking = false;
        } else if (((input.right &amp;&amp; cLeft) || (input.left &amp;&amp; cRight)) &amp;&amp; canStick &amp;&amp; !onGround) {
            alarm[0] = clingTime;
            sticking = true; 
            canStick = false;       
        }
    }
    */
    
    // Handle gravity
    if (!onGround) {
        /*if (wallJump &amp;&amp; (cLeft || cRight) &amp;&amp; vy &gt;= 0) {
            // Wall slide
            vy = scr_approach(vy, vyMax * 0.33, gravSlide);
        } else {*/
            // Fall normally
            vy = scr_approach(vy, vyMax, gravNorm);
        //}
    }
    
    // Left 
    if (input.left &amp;&amp; !input.right &amp;&amp; !sticking) {
        facing = -1;
        movement  = MOVE;
        
        // Apply acceleration left
        if (vx &gt; 0)
            vx = scr_approach(vx, 0, tempFric);   // This seems to impart a kind of SKID effect
                                                  // before allowing the player to move.
        vx = scr_approach(vx, -vxMax, tempAccel);
    // Right
    } else if (input.right &amp;&amp; !input.left &amp;&amp; !sticking) {
        facing = 1;
        movement  = MOVE;
        
        // Apply acceleration right
        if (vx &lt; 0)
            vx = scr_approach(vx, 0, tempFric);   
        vx = scr_approach(vx, vxMax, tempAccel);
    }
    
    // Friction
    if (!input.right &amp;&amp; !input.left) {
        vx    = scr_approach(vx, 0, tempFric);
        movement = IDLE;
    } 
     
    /*
    // Wall jump
    if (wallJump) {
        if (input.upPressed &amp;&amp; cLeft &amp;&amp; !onGround) {   
            xscale = 0.5;
            yscale = 1.5;
              
            // audio_play_sound(sfxJump, 0, 0);    
                       
            // Wall jump is different when pushing off/towards the wall        
            if (input.left) {
                vx = jumpHeight * .75;
                vy = -jumpHeight * 1.1;
            } else {
                vx = vxMax;    
                vy = -jumpHeight * 1.1;
            }  
        } else if (input.upPressed &amp;&amp; cRight &amp;&amp; !onGround) {   
            xscale = 0.5;
            yscale = 1.5;
               
            // audio_play_sound(sfxJump, 0, 0); 
                                    
            // Wall jump is different when pushing off/towards the wall  
            if (input.right) {
                vx = -jumpHeight * .75;
                vy = -jumpHeight * 1.1;
            } else {
                vx = -vxMax;    
                vy = -jumpHeight * 1.1;
            }  
        }
    }
    */
    
    // Jump
    if (input.upPressed) { 
        if (onGround || onGroundPrev) {
            // Fall thru platform
            //if (input.downPressed) &amp;&amp; (place_meeting(x, y + 1, oParJumpThru) &amp;&amp; !place_meeting(x, y + 1, oParSolid)) {
            //        ++y;
            // Normal jump
            //} else {
            
            // stretch image
                xscale = 0.5;
                yscale = 1.5;
                
                vy = -jumpHeight;
                
                //audio_play_sound(choose(sfxHerp, sfxHop, sfxOoh, sfxBeh), 0, 0);
                //audio_play_sound(sfxJump, 0, 0);
            //}
        } else {
            /*
            if (dblJump &amp;&amp; canDblJump &amp;&amp; !cRight &amp;&amp; !cLeft &amp;&amp; !input.down) {
                xscale = 0.5;
                yscale = 1.5;
                
                vy = -jumpHeight;
                      
                // Double jump paint spread
                
                if (dblJumpSpray) 
                    for (var i = 0; i &lt; 24; i++)
                        instance_create(x, y - 8, oPaintBullet);
                         
                canDblJump = false;
                
                
                //audio_play_sound(sfxJump2, 0, 0);
            }
            */
        }
    // Variable jumping
    } else if (input.upReleased) { 
        if (vy &lt; 0)
            vy *= 0.25;
    }
    
    // Jump movement
    if (!onGround) {
        movement = JUMP;
        /*
        if (cLeft)
            facing = 1;
        if (cRight)
            facing = -1;
        */
    }
    
    // Spit ball out
    
    if input.downPressed &amp;&amp; ballHeld == true {
        ballHeld = false;
        canCatch = false;
        alarm[2] = room_speed/3;
        var tx = vx;
        var ty = vy;
        if facing == RIGHT { tx += 10; } else { tx += -10; }
        with o_ball {
            state = scr_ballStateDefault;
            vx = tx;
            vy = ty;
            owner = noone;
        }
        
        
    }

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set holder and sensor

if facing = RIGHT {
    holder.x = x+holder_offset_x;
    holder.y = y-holder_offset_y;
} else {
    holder.x = x-holder_offset_x;
    holder.y = y-holder_offset_y;
}

if facing = RIGHT {
    sensor.x = x+sensor_offset_x;
    sensor.y = y-sensor_offset_y;;
} else {
    sensor.x = x-sensor_offset_x;
    sensor.y = y-sensor_offset_y;;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Face ball when round starts

if instance_exists(o_ball) {
    if o_ball.x &lt; x {
        show_debug_message("FACE LEFT");
        facing = LEFT;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the player
if (canDblJump)
    image_alpha = 1;
else {
    if (blink)
        image_alpha = 1;
    else
        image_alpha = 0.5;
}

blink = !blink;

// Draw player

/*
for (var i = 0; i &lt; blur; i++) {
    draw_sprite_pos(sprite_index, image_index, ax[i] - (sprite_width - av[i]) * axs[i] * 0.5, ay[i] - (sprite_height + (av[i]*0.5)) * ays[i], ax[i] + (sprite_width + av[i]) * axs[i] * 0.5, ay[i] - (sprite_height - (av[i]*0.5)) * ays[i], ax[i] + sprite_width * axs[i] * 0.5, ay[i], ax[i] - sprite_width * axs[i] * 0.5, ay[i],  image_alpha - i * 0.3);
}
*/

// *** I don't know?? I think it's meant to deal with image squash
/*draw_sprite_pos(sprite_index, 
image_index, 
x - (sprite_width - val) * xscale * 0.5,
y - (sprite_height + (val*0.5)) * yscale, 
x + (sprite_width + val) * xscale * 0.5, 
y - (sprite_height + (val*0.5)) * yscale, 
x + sprite_width * xscale * 0.5, 
y + ((sprite_height / 2) + (val*0.5)), 
x - sprite_width * xscale * 0.5, 
y + ((sprite_height / 2) + (val*0.5)), 
image_alpha);*/
draw_sprite_ext(sprite_index, image_index, x, y, facing * xscale, yscale, 0, c_white, image_alpha);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
